import{cH as Oe,cI as Zn,cJ as Dn,cK as Yn,cL as Wn,J as Je,cM as Fn,cN as bt,bG as P,bC as W,bU as tn,bK as Kn,bH as le,cO as Gn,cP as Xn,bB as k,aB as Y,bI as q,bF as st,bD as It,bA as en,bL as vt,cQ as nn,cR as Qn,bE as he,cS as Ne,cT as Jn,cU as tr,cV as er,cW as nr,cX as rr,b2 as ir,cY as Re,B as sr,a4 as Ct,D as ye,cZ as te,c_ as or,m as Ue,p as ar,k as cr,bp as ur,c$ as fr,C as dr,W as lr,n as Le,e as rn,d0 as hr,d1 as yr,d2 as sn,d3 as Ce,d4 as pr,d5 as gr,a9 as mr,d6 as wr,d7 as br,a$ as Er}from"./index-CHozcNii.js";import{i as on}from"./isAddressEqual-DT7yxKk4.js";function Te(t){let e;if(typeof t=="string")e=Oe(t);else{const n=Zn(t),r=t.length;for(let i=0;i<r;i++){const s=t[i];if(!Dn(s)){e=Oe(s,n);break}}}if(!e)throw new Yn({signature:t});return e}async function xr({address:t,authorization:e,signature:n}){return on(Je(t),await Wn({authorization:e,signature:n}))}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const pe=BigInt(0),ee=BigInt(1);function Pt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function ge(t){if(!Pt(t))throw new Error("Uint8Array expected")}function Bt(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}function Ot(t){const e=t.toString(16);return e.length&1?"0"+e:e}function an(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?pe:BigInt("0x"+t)}const cn=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",vr=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function St(t){if(ge(t),cn)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=vr[t[n]];return e}const tt={_0:48,_9:57,A:65,F:70,a:97,f:102};function _e(t){if(t>=tt._0&&t<=tt._9)return t-tt._0;if(t>=tt.A&&t<=tt.F)return t-(tt.A-10);if(t>=tt.a&&t<=tt.f)return t-(tt.a-10)}function Rt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(cn)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let i=0,s=0;i<n;i++,s+=2){const a=_e(t.charCodeAt(s)),c=_e(t.charCodeAt(s+1));if(a===void 0||c===void 0){const o=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+o+'" at index '+s)}r[i]=a*16+c}return r}function ft(t){return an(St(t))}function un(t){return ge(t),an(St(Uint8Array.from(t).reverse()))}function $t(t,e){return Rt(t.toString(16).padStart(e*2,"0"))}function fn(t,e){return $t(t,e).reverse()}function K(t,e,n){let r;if(typeof e=="string")try{r=Rt(e)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(Pt(e))r=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const i=r.length;if(typeof n=="number"&&i!==n)throw new Error(t+" of length "+n+" expected, got "+i);return r}function Ut(...t){let e=0;for(let r=0;r<t.length;r++){const i=t[r];ge(i),e+=i.length}const n=new Uint8Array(e);for(let r=0,i=0;r<t.length;r++){const s=t[r];n.set(s,i),i+=s.length}return n}const Zt=t=>typeof t=="bigint"&&pe<=t;function me(t,e,n){return Zt(t)&&Zt(e)&&Zt(n)&&e<=t&&t<n}function mt(t,e,n,r){if(!me(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function Br(t){let e;for(e=0;t>pe;t>>=ee,e+=1);return e}const Tt=t=>(ee<<BigInt(t))-ee,Dt=t=>new Uint8Array(t),ke=t=>Uint8Array.from(t);function Sr(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=Dt(t),i=Dt(t),s=0;const a=()=>{r.fill(1),i.fill(0),s=0},c=(...y)=>n(i,r,...y),o=(y=Dt(0))=>{i=c(ke([0]),y),r=c(),y.length!==0&&(i=c(ke([1]),y),r=c())},u=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let y=0;const w=[];for(;y<e;){r=c();const z=r.slice();w.push(z),y+=r.length}return Ut(...w)};return(y,w)=>{a(),o(y);let z;for(;!(z=w(u()));)o();return a(),z}}const Ar={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||Pt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function _t(t,e,n={}){const r=(i,s,a)=>{const c=Ar[s];if(typeof c!="function")throw new Error("invalid validator function");const o=t[i];if(!(a&&o===void 0)&&!c(o,t))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+o)};for(const[i,s]of Object.entries(e))r(i,s,!1);for(const[i,s]of Object.entries(n))r(i,s,!0);return t}function qe(t){const e=new WeakMap;return(n,...r)=>{const i=e.get(n);if(i!==void 0)return i;const s=t(n,...r);return e.set(n,s),s}}function zt(t,e){if(Q(t)>e)throw new Mr({givenSize:Q(t),maxSize:e})}function Ir(t,e){if(typeof e=="number"&&e>0&&e>Q(t)-1)throw new hn({offset:e,position:"start",size:Q(t)})}function Pr(t,e,n){if(typeof e=="number"&&typeof n=="number"&&Q(t)!==n-e)throw new hn({offset:n,position:"end",size:Q(t)})}const et={zero:48,nine:57,A:65,F:70,a:97,f:102};function Ve(t){if(t>=et.zero&&t<=et.nine)return t-et.zero;if(t>=et.A&&t<=et.F)return t-(et.A-10);if(t>=et.a&&t<=et.f)return t-(et.a-10)}function $r(t,e={}){const{dir:n,size:r=32}=e;if(r===0)return t;if(t.length>r)throw new Hr({size:t.length,targetSize:r,type:"Bytes"});const i=new Uint8Array(r);for(let s=0;s<r;s++){const a=n==="right";i[a?s:r-s-1]=t[a?s:t.length-s-1]}return i}function dn(t,e={}){const{dir:n="left"}=e;let r=t,i=0;for(let s=0;s<r.length-1&&r[n==="left"?s:r.length-s-1].toString()==="0";s++)i++;return r=n==="left"?r.slice(i):r.slice(0,r.length-i),r}const zr=new TextDecoder,Or=new TextEncoder;function Nr(t){if(!(t instanceof Uint8Array)){if(!t)throw new Nt(t);if(typeof t!="object")throw new Nt(t);if(!("BYTES_PER_ELEMENT"in t))throw new Nt(t);if(t.BYTES_PER_ELEMENT!==1||t.constructor.name!=="Uint8Array")throw new Nt(t)}}function Lt(t){return t instanceof Uint8Array?t:typeof t=="string"?we(t):Rr(t)}function Rr(t){return t instanceof Uint8Array?t:new Uint8Array(t)}function we(t,e={}){const{size:n}=e;let r=t;n&&(Fn(t,n),r=bt(t,n));let i=r.slice(2);i.length%2&&(i=`0${i}`);const s=i.length/2,a=new Uint8Array(s);for(let c=0,o=0;c<s;c++){const u=Ve(i.charCodeAt(o++)),f=Ve(i.charCodeAt(o++));if(u===void 0||f===void 0)throw new P(`Invalid byte sequence ("${i[o-2]}${i[o-1]}" in "${i}").`);a[c]=u*16+f}return a}function Ur(t,e={}){const{size:n}=e,r=Or.encode(t);return typeof n=="number"?(zt(r,n),Lr(r,n)):r}function Lr(t,e){return $r(t,{dir:"right",size:e})}function Q(t){return t.length}function Cr(t,e,n,r={}){const{strict:i}=r;Ir(t,e);const s=t.slice(e,n);return i&&Pr(s,e,n),s}function Tr(t,e={}){const{size:n}=e;typeof n<"u"&&zt(t,n);const r=W(t,e);return Kn(r,e)}function _r(t,e={}){const{size:n}=e;let r=t;if(typeof n<"u"&&(zt(r,n),r=ln(r)),r.length>1||r[0]>1)throw new jr(r);return!!r[0]}function _s(t,e={}){return W(t,e)}function it(t,e={}){const{size:n}=e;typeof n<"u"&&zt(t,n);const r=W(t,e);return tn(r,e)}function kr(t,e={}){const{size:n}=e;let r=t;return typeof n<"u"&&(zt(r,n),r=qr(r)),zr.decode(r)}function ln(t){return dn(t,{dir:"left"})}function qr(t){return dn(t,{dir:"right"})}function Vr(t){try{return Nr(t),!0}catch{return!1}}class jr extends P{constructor(e){super(`Bytes value \`${e}\` is not a valid boolean.`,{metaMessages:["The bytes array must contain a single byte of either a `0` or `1` value."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.InvalidBytesBooleanError"})}}class Nt extends P{constructor(e){super(`Value \`${typeof e=="object"?le(e):e}\` of type \`${typeof e}\` is an invalid Bytes value.`,{metaMessages:["Bytes values must be of type `Bytes`."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.InvalidBytesTypeError"})}}class Mr extends P{constructor({givenSize:e,maxSize:n}){super(`Size cannot exceed \`${n}\` bytes. Given size: \`${e}\` bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeOverflowError"})}}class hn extends P{constructor({offset:e,position:n,size:r}){super(`Slice ${n==="start"?"starting":"ending"} at offset \`${e}\` is out-of-bounds (size: \`${r}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SliceOffsetOutOfBoundsError"})}}class Hr extends P{constructor({size:e,targetSize:n,type:r}){super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${n}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Bytes.SizeExceedsPaddingSizeError"})}}class Zr extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}get(e){const n=super.get(e);return super.has(e)&&n!==void 0&&(this.delete(e),super.set(e,n)),n}set(e,n){if(super.set(e,n),this.maxSize&&this.size>this.maxSize){const r=this.keys().next().value;r&&this.delete(r)}return this}}const Dr={checksum:new Zr(8192)},Yt=Dr.checksum;function kt(t,e={}){const{as:n=typeof t=="string"?"Hex":"Bytes"}=e,r=Gn(Lt(t));return n==="Bytes"?r:W(r)}function ks(t,e={}){const{as:n=typeof t=="string"?"Hex":"Bytes"}=e,r=Xn(Lt(t));return n==="Bytes"?r:W(r)}function yn(t,e={}){const{compressed:n}=e,{prefix:r,x:i,y:s}=t;if(n===!1||typeof i=="bigint"&&typeof s=="bigint"){if(r!==4)throw new je({prefix:r,cause:new Gr});return}if(n===!0||typeof i=="bigint"&&typeof s>"u"){if(r!==3&&r!==2)throw new je({prefix:r,cause:new Kr});return}throw new Fr({publicKey:t})}function pn(t){const e=(()=>{if(en(t))return gn(t);if(Vr(t))return Yr(t);const{prefix:n,x:r,y:i}=t;return typeof r=="bigint"&&typeof i=="bigint"?{prefix:n??4,x:r,y:i}:{prefix:n,x:r}})();return yn(e),e}function Yr(t){return gn(W(t))}function gn(t){if(t.length!==132&&t.length!==130&&t.length!==68)throw new Xr({publicKey:t});if(t.length===130){const r=BigInt(k(t,0,32)),i=BigInt(k(t,32,64));return{prefix:4,x:r,y:i}}if(t.length===132){const r=Number(k(t,0,1)),i=BigInt(k(t,1,33)),s=BigInt(k(t,33,65));return{prefix:r,x:i,y:s}}const e=Number(k(t,0,1)),n=BigInt(k(t,1,33));return{prefix:e,x:n}}function Wr(t,e={}){yn(t);const{prefix:n,x:r,y:i}=t,{includePrefix:s=!0}=e;return Y(s?q(n,{size:1}):"0x",q(r,{size:32}),typeof i=="bigint"?q(i,{size:32}):"0x")}class Fr extends P{constructor({publicKey:e}){super(`Value \`${le(e)}\` is not a valid public key.`,{metaMessages:["Public key must contain:","- an `x` and `prefix` value (compressed)","- an `x`, `y`, and `prefix` value (uncompressed)"]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidError"})}}class je extends P{constructor({prefix:e,cause:n}){super(`Prefix "${e}" is invalid.`,{cause:n}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidPrefixError"})}}class Kr extends P{constructor(){super("Prefix must be 2 or 3 for compressed public keys."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidCompressedPrefixError"})}}class Gr extends P{constructor(){super("Prefix must be 4 for uncompressed public keys."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidUncompressedPrefixError"})}}let Xr=class extends P{constructor({publicKey:e}){super(`Value \`${e}\` is an invalid public key size.`,{metaMessages:["Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",`Received ${st(It(e))} bytes.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PublicKey.InvalidSerializedSizeError"})}};const Qr=/^0x[a-fA-F0-9]{40}$/;function dt(t,e={}){const{strict:n=!0}=e;if(!Qr.test(t))throw new Me({address:t,cause:new ei});if(n){if(t.toLowerCase()===t)return;if(be(t)!==t)throw new Me({address:t,cause:new ni})}}function be(t){if(Yt.has(t))return Yt.get(t);dt(t,{strict:!1});const e=t.substring(2).toLowerCase(),n=kt(Ur(e),{as:"Bytes"}),r=e.split("");for(let s=0;s<40;s+=2)n[s>>1]>>4>=8&&r[s]&&(r[s]=r[s].toUpperCase()),(n[s>>1]&15)>=8&&r[s+1]&&(r[s+1]=r[s+1].toUpperCase());const i=`0x${r.join("")}`;return Yt.set(t,i),i}function Jr(t,e={}){const{checksum:n=!1}=e;return dt(t),n?be(t):t}function ti(t,e={}){const n=kt(`0x${Wr(t).slice(4)}`).substring(26);return Jr(`0x${n}`,e)}function Vs(t,e){return dt(t,{strict:!1}),dt(e,{strict:!1}),t.toLowerCase()===e.toLowerCase()}function ne(t,e={}){const{strict:n=!0}=e??{};try{return dt(t,{strict:n}),!0}catch{return!1}}class Me extends P{constructor({address:e,cause:n}){super(`Address "${e}" is invalid.`,{cause:n}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidAddressError"})}}class ei extends P{constructor(){super("Address is not a 20 byte (40 hexadecimal character) value."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidInputError"})}}class ni extends P{constructor(){super("Address does not match its checksum counterpart."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidChecksumError"})}}const ri=/^(.*)\[([0-9]*)\]$/,ii=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,mn=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,He=2n**256n-1n;function wt(t,e,n){const{checksumAddress:r,staticPosition:i}=n,s=ve(e.type);if(s){const[a,c]=s;return oi(t,{...e,type:c},{checksumAddress:r,length:a,staticPosition:i})}if(e.type==="tuple")return fi(t,e,{checksumAddress:r,staticPosition:i});if(e.type==="address")return si(t,{checksum:r});if(e.type==="bool")return ai(t);if(e.type.startsWith("bytes"))return ci(t,e,{staticPosition:i});if(e.type.startsWith("uint")||e.type.startsWith("int"))return ui(t,e);if(e.type==="string")return di(t,{staticPosition:i});throw new Se(e.type)}const Ze=32,re=32;function si(t,e={}){const{checksum:n=!1}=e,r=t.readBytes(32);return[(s=>n?be(s):s)(W(Cr(r,-20))),32]}function oi(t,e,n){const{checksumAddress:r,length:i,staticPosition:s}=n;if(!i){const o=it(t.readBytes(re)),u=s+o,f=u+Ze;t.setPosition(u);const y=it(t.readBytes(Ze)),w=At(e);let z=0;const R=[];for(let g=0;g<y;++g){t.setPosition(f+(w?g*32:z));const[_,C]=wt(t,e,{checksumAddress:r,staticPosition:f});z+=C,R.push(_)}return t.setPosition(s+32),[R,32]}if(At(e)){const o=it(t.readBytes(re)),u=s+o,f=[];for(let y=0;y<i;++y){t.setPosition(u+y*32);const[w]=wt(t,e,{checksumAddress:r,staticPosition:u});f.push(w)}return t.setPosition(s+32),[f,32]}let a=0;const c=[];for(let o=0;o<i;++o){const[u,f]=wt(t,e,{checksumAddress:r,staticPosition:s+a});a+=f,c.push(u)}return[c,a]}function ai(t){return[_r(t.readBytes(32),{size:32}),32]}function ci(t,e,{staticPosition:n}){const[r,i]=e.type.split("bytes");if(!i){const a=it(t.readBytes(32));t.setPosition(n+a);const c=it(t.readBytes(32));if(c===0)return t.setPosition(n+32),["0x",32];const o=t.readBytes(c);return t.setPosition(n+32),[W(o),32]}return[W(t.readBytes(Number.parseInt(i,10),32)),32]}function ui(t,e){const n=e.type.startsWith("int"),r=Number.parseInt(e.type.split("int")[1]||"256",10),i=t.readBytes(32);return[r>48?Tr(i,{signed:n}):it(i,{signed:n}),32]}function fi(t,e,n){const{checksumAddress:r,staticPosition:i}=n,s=e.components.length===0||e.components.some(({name:o})=>!o),a=s?[]:{};let c=0;if(At(e)){const o=it(t.readBytes(re)),u=i+o;for(let f=0;f<e.components.length;++f){const y=e.components[f];t.setPosition(u+c);const[w,z]=wt(t,y,{checksumAddress:r,staticPosition:u});c+=z,a[s?f:y?.name]=w}return t.setPosition(i+32),[a,32]}for(let o=0;o<e.components.length;++o){const u=e.components[o],[f,y]=wt(t,u,{checksumAddress:r,staticPosition:i});a[s?o:u?.name]=f,c+=y}return[a,c]}function di(t,{staticPosition:e}){const n=it(t.readBytes(32)),r=e+n;t.setPosition(r);const i=it(t.readBytes(32));if(i===0)return t.setPosition(e+32),["",32];const s=t.readBytes(i,32),a=kr(ln(s));return t.setPosition(e+32),[a,32]}function li({checksumAddress:t,parameters:e,values:n}){const r=[];for(let i=0;i<e.length;i++)r.push(Ee({checksumAddress:t,parameter:e[i],value:n[i]}));return r}function Ee({checksumAddress:t=!1,parameter:e,value:n}){const r=e,i=ve(r.type);if(i){const[s,a]=i;return yi(n,{checksumAddress:t,length:s,parameter:{...r,type:a}})}if(r.type==="tuple")return bi(n,{checksumAddress:t,parameter:r});if(r.type==="address")return hi(n,{checksum:t});if(r.type==="bool")return gi(n);if(r.type.startsWith("uint")||r.type.startsWith("int")){const s=r.type.startsWith("int"),[,,a="256"]=mn.exec(r.type)??[];return mi(n,{signed:s,size:Number(a)})}if(r.type.startsWith("bytes"))return pi(n,{type:r.type});if(r.type==="string")return wi(n);throw new Se(r.type)}function xe(t){let e=0;for(let s=0;s<t.length;s++){const{dynamic:a,encoded:c}=t[s];a?e+=32:e+=st(c)}const n=[],r=[];let i=0;for(let s=0;s<t.length;s++){const{dynamic:a,encoded:c}=t[s];a?(n.push(q(e+i,{size:32})),r.push(c),i+=st(c)):n.push(c)}return Y(...n,...r)}function hi(t,e){const{checksum:n=!1}=e;return dt(t,{strict:n}),{dynamic:!1,encoded:vt(t.toLowerCase())}}function yi(t,e){const{checksumAddress:n,length:r,parameter:i}=e,s=r===null;if(!Array.isArray(t))throw new Pi(t);if(!s&&t.length!==r)throw new Ii({expectedLength:r,givenLength:t.length,type:`${i.type}[${r}]`});let a=!1;const c=[];for(let o=0;o<t.length;o++){const u=Ee({checksumAddress:n,parameter:i,value:t[o]});u.dynamic&&(a=!0),c.push(u)}if(s||a){const o=xe(c);if(s){const u=q(c.length,{size:32});return{dynamic:!0,encoded:c.length>0?Y(u,o):u}}if(a)return{dynamic:!0,encoded:o}}return{dynamic:!1,encoded:Y(...c.map(({encoded:o})=>o))}}function pi(t,{type:e}){const[,n]=e.split("bytes"),r=st(t);if(!n){let i=t;return r%32!==0&&(i=bt(i,Math.ceil((t.length-2)/2/32)*32)),{dynamic:!0,encoded:Y(vt(q(r,{size:32})),i)}}if(r!==Number.parseInt(n,10))throw new En({expectedSize:Number.parseInt(n,10),value:t});return{dynamic:!1,encoded:bt(t)}}function gi(t){if(typeof t!="boolean")throw new P(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:vt(nn(t))}}function mi(t,{signed:e,size:n}){if(typeof n=="number"){const r=2n**(BigInt(n)-(e?1n:0n))-1n,i=e?-r-1n:0n;if(t>r||t<i)throw new Qn({max:r.toString(),min:i.toString(),signed:e,size:n/8,value:t.toString()})}return{dynamic:!1,encoded:q(t,{size:32,signed:e})}}function wi(t){const e=he(t),n=Math.ceil(st(e)/32),r=[];for(let i=0;i<n;i++)r.push(bt(k(e,i*32,(i+1)*32)));return{dynamic:!0,encoded:Y(bt(q(st(e),{size:32})),...r)}}function bi(t,e){const{checksumAddress:n,parameter:r}=e;let i=!1;const s=[];for(let a=0;a<r.components.length;a++){const c=r.components[a],o=Array.isArray(t)?a:c.name,u=Ee({checksumAddress:n,parameter:c,value:t[o]});s.push(u),u.dynamic&&(i=!0)}return{dynamic:i,encoded:i?xe(s):Y(...s.map(({encoded:a})=>a))}}function ve(t){const e=t.match(/^(.*)\[(\d+)?\]$/);return e?[e[2]?Number(e[2]):null,e[1]]:void 0}function At(t){const{type:e}=t;if(e==="string"||e==="bytes"||e.endsWith("[]"))return!0;if(e==="tuple")return t.components?.some(At);const n=ve(t.type);return!!(n&&At({...t,type:n[1]}))}const Ei={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:Number.POSITIVE_INFINITY,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new vi({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(t){if(t<0||t>this.bytes.length-1)throw new xi({length:this.bytes.length,position:t})},decrementPosition(t){if(t<0)throw new De({offset:t});const e=this.position-t;this.assertPosition(e),this.position=e},getReadCount(t){return this.positionReadCount.get(t||this.position)||0},incrementPosition(t){if(t<0)throw new De({offset:t});const e=this.position+t;this.assertPosition(e),this.position=e},inspectByte(t){const e=t??this.position;return this.assertPosition(e),this.bytes[e]},inspectBytes(t,e){const n=e??this.position;return this.assertPosition(n+t-1),this.bytes.subarray(n,n+t)},inspectUint8(t){const e=t??this.position;return this.assertPosition(e),this.bytes[e]},inspectUint16(t){const e=t??this.position;return this.assertPosition(e+1),this.dataView.getUint16(e)},inspectUint24(t){const e=t??this.position;return this.assertPosition(e+2),(this.dataView.getUint16(e)<<8)+this.dataView.getUint8(e+2)},inspectUint32(t){const e=t??this.position;return this.assertPosition(e+3),this.dataView.getUint32(e)},pushByte(t){this.assertPosition(this.position),this.bytes[this.position]=t,this.position++},pushBytes(t){this.assertPosition(this.position+t.length-1),this.bytes.set(t,this.position),this.position+=t.length},pushUint8(t){this.assertPosition(this.position),this.bytes[this.position]=t,this.position++},pushUint16(t){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,t),this.position+=2},pushUint24(t){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,t>>8),this.dataView.setUint8(this.position+2,t&255),this.position+=3},pushUint32(t){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,t),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const t=this.inspectByte();return this.position++,t},readBytes(t,e){this.assertReadLimit(),this._touch();const n=this.inspectBytes(t);return this.position+=e??t,n},readUint8(){this.assertReadLimit(),this._touch();const t=this.inspectUint8();return this.position+=1,t},readUint16(){this.assertReadLimit(),this._touch();const t=this.inspectUint16();return this.position+=2,t},readUint24(){this.assertReadLimit(),this._touch();const t=this.inspectUint24();return this.position+=3,t},readUint32(){this.assertReadLimit(),this._touch();const t=this.inspectUint32();return this.position+=4,t},get remaining(){return this.bytes.length-this.position},setPosition(t){const e=this.position;return this.assertPosition(t),this.position=t,()=>this.position=e},_touch(){if(this.recursiveReadLimit===Number.POSITIVE_INFINITY)return;const t=this.getReadCount();this.positionReadCount.set(this.position,t+1),t>0&&this.recursiveReadCount++}};function wn(t,{recursiveReadLimit:e=8192}={}){const n=Object.create(Ei);return n.bytes=t,n.dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),n.positionReadCount=new Map,n.recursiveReadLimit=e,n}class De extends P{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Cursor.NegativeOffsetError"})}}class xi extends P{constructor({length:e,position:n}){super(`Position \`${n}\` is out of bounds (\`0 < position < ${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Cursor.PositionOutOfBoundsError"})}}class vi extends P{constructor({count:e,limit:n}){super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Cursor.RecursiveReadLimitExceededError"})}}function Bi(t,e,n={}){const{as:r="Array",checksumAddress:i=!1}=n,s=typeof e=="string"?we(e):e,a=wn(s);if(Q(s)===0&&t.length>0)throw new Ai;if(Q(s)&&Q(s)<32)throw new Si({data:typeof e=="string"?e:W(e),parameters:t,size:Q(s)});let c=0;const o=r==="Array"?[]:{};for(let u=0;u<t.length;++u){const f=t[u];a.setPosition(c);const[y,w]=wt(a,f,{checksumAddress:i,staticPosition:0});c+=w,r==="Array"?o.push(y):o[f.name??u]=y}return o}function Be(t,e,n){const{checksumAddress:r=!1}={};if(t.length!==e.length)throw new xn({expectedLength:t.length,givenLength:e.length});const i=li({checksumAddress:r,parameters:t,values:e}),s=xe(i);return s.length===0?"0x":s}function ie(t,e){if(t.length!==e.length)throw new xn({expectedLength:t.length,givenLength:e.length});const n=[];for(let r=0;r<t.length;r++){const i=t[r],s=e[r];n.push(ie.encode(i,s))}return Y(...n)}(function(t){function e(n,r,i=!1){if(n==="address"){const o=r;return dt(o),vt(o.toLowerCase(),i?32:0)}if(n==="string")return he(r);if(n==="bytes")return r;if(n==="bool")return vt(nn(r),i?32:1);const s=n.match(mn);if(s){const[o,u,f="256"]=s,y=Number.parseInt(f,10)/8;return q(r,{size:i?32:y,signed:u==="int"})}const a=n.match(ii);if(a){const[o,u]=a;if(Number.parseInt(u,10)!==(r.length-2)/2)throw new En({expectedSize:Number.parseInt(u,10),value:r});return bt(r,i?32:0)}const c=n.match(ri);if(c&&Array.isArray(r)){const[o,u]=c,f=[];for(let y=0;y<r.length;y++)f.push(e(u,r[y],!0));return f.length===0?"0x":Y(...f)}throw new Se(n)}t.encode=e})(ie||(ie={}));function bn(t){return Array.isArray(t)&&typeof t[0]=="string"?Ne(t):typeof t=="string"?Ne(t):t}class Si extends P{constructor({data:e,parameters:n,size:r}){super(`Data size of ${r} bytes is too small for given parameters.`,{metaMessages:[`Params: (${Jn(n)})`,`Data:   ${e} (${r} bytes)`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.DataSizeTooSmallError"})}}class Ai extends P{constructor(){super('Cannot decode zero data ("0x") with ABI parameters.'),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.ZeroDataError"})}}class Ii extends P{constructor({expectedLength:e,givenLength:n,type:r}){super(`Array length mismatch for type \`${r}\`. Expected: \`${e}\`. Given: \`${n}\`.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.ArrayLengthMismatchError"})}}class En extends P{constructor({expectedSize:e,value:n}){super(`Size of bytes "${n}" (bytes${st(n)}) does not match expected size (bytes${e}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.BytesSizeMismatchError"})}}class xn extends P{constructor({expectedLength:e,givenLength:n}){super(["ABI encoding parameters/values length mismatch.",`Expected length (parameters): ${e}`,`Given length (values): ${n}`].join(`
`)),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.LengthMismatchError"})}}class Pi extends P{constructor(e){super(`Value \`${e}\` is not a valid array.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidArrayError"})}}class Se extends P{constructor(e){super(`Type \`${e}\` is not a valid ABI Type.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidTypeError"})}}function $i(t,e){const{as:n}=e,r=vn(t),i=wn(new Uint8Array(r.length));return r.encode(i),n==="Hex"?W(i.bytes):i.bytes}function zi(t,e={}){const{as:n="Hex"}=e;return $i(t,{as:n})}function vn(t){return Array.isArray(t)?Oi(t.map(e=>vn(e))):Ni(t)}function Oi(t){const e=t.reduce((i,s)=>i+s.length,0),n=Bn(e);return{length:e<=55?1+e:1+n+e,encode(i){e<=55?i.pushByte(192+e):(i.pushByte(247+n),n===1?i.pushUint8(e):n===2?i.pushUint16(e):n===3?i.pushUint24(e):i.pushUint32(e));for(const{encode:s}of t)s(i)}}}function Ni(t){const e=typeof t=="string"?we(t):t,n=Bn(e.length);return{length:e.length===1&&e[0]<128?1:e.length<=55?1+e.length:1+n+e.length,encode(i){e.length===1&&e[0]<128?i.pushBytes(e):e.length<=55?(i.pushByte(128+e.length),i.pushBytes(e)):(i.pushByte(183+n),n===1?i.pushUint8(e.length):n===2?i.pushUint16(e.length):n===3?i.pushUint24(e.length):i.pushUint32(e.length),i.pushBytes(e))}}}function Bn(t){if(t<2**8)return 1;if(t<2**16)return 2;if(t<2**24)return 3;if(t<2**32)return 4;throw new P("Length is too large.")}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const D=BigInt(0),M=BigInt(1),ut=BigInt(2),Ri=BigInt(3),Sn=BigInt(4),An=BigInt(5),In=BigInt(8);function Z(t,e){const n=t%e;return n>=D?n:e+n}function F(t,e,n){let r=t;for(;e-- >D;)r*=r,r%=n;return r}function se(t,e){if(t===D)throw new Error("invert: expected non-zero number");if(e<=D)throw new Error("invert: expected positive modulus, got "+e);let n=Z(t,e),r=e,i=D,s=M;for(;n!==D;){const c=r/n,o=r%n,u=i-s*c;r=n,n=o,i=s,s=u}if(r!==M)throw new Error("invert: does not exist");return Z(i,e)}function Pn(t,e){const n=(t.ORDER+M)/Sn,r=t.pow(e,n);if(!t.eql(t.sqr(r),e))throw new Error("Cannot find square root");return r}function Ui(t,e){const n=(t.ORDER-An)/In,r=t.mul(e,ut),i=t.pow(r,n),s=t.mul(e,i),a=t.mul(t.mul(s,ut),i),c=t.mul(s,t.sub(a,t.ONE));if(!t.eql(t.sqr(c),e))throw new Error("Cannot find square root");return c}function Li(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let e=t-M,n=0;for(;e%ut===D;)e/=ut,n++;let r=ut;const i=Ae(t);for(;Ye(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return Pn;let s=i.pow(r,e);const a=(e+M)/ut;return function(o,u){if(o.is0(u))return u;if(Ye(o,u)!==1)throw new Error("Cannot find square root");let f=n,y=o.mul(o.ONE,s),w=o.pow(u,e),z=o.pow(u,a);for(;!o.eql(w,o.ONE);){if(o.is0(w))return o.ZERO;let R=1,g=o.sqr(w);for(;!o.eql(g,o.ONE);)if(R++,g=o.sqr(g),R===f)throw new Error("Cannot find square root");const _=M<<BigInt(f-R-1),C=o.pow(y,_);f=R,y=o.sqr(C),w=o.mul(w,y),z=o.mul(z,C)}return z}}function Ci(t){return t%Sn===Ri?Pn:t%In===An?Ui:Li(t)}const Ti=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function _i(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=Ti.reduce((r,i)=>(r[i]="function",r),e);return _t(t,n)}function ki(t,e,n){if(n<D)throw new Error("invalid exponent, negatives unsupported");if(n===D)return t.ONE;if(n===M)return e;let r=t.ONE,i=e;for(;n>D;)n&M&&(r=t.mul(r,i)),i=t.sqr(i),n>>=M;return r}function $n(t,e,n=!1){const r=new Array(e.length).fill(n?t.ZERO:void 0),i=e.reduce((a,c,o)=>t.is0(c)?a:(r[o]=a,t.mul(a,c)),t.ONE),s=t.inv(i);return e.reduceRight((a,c,o)=>t.is0(c)?a:(r[o]=t.mul(a,r[o]),t.mul(a,c)),s),r}function Ye(t,e){const n=(t.ORDER-M)/ut,r=t.pow(e,n),i=t.eql(r,t.ONE),s=t.eql(r,t.ZERO),a=t.eql(r,t.neg(t.ONE));if(!i&&!s&&!a)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function zn(t,e){e!==void 0&&tr(e);const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Ae(t,e,n=!1,r={}){if(t<=D)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:s}=zn(t,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const c=Object.freeze({ORDER:t,isLE:n,BITS:i,BYTES:s,MASK:Tt(i),ZERO:D,ONE:M,create:o=>Z(o,t),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return D<=o&&o<t},is0:o=>o===D,isOdd:o=>(o&M)===M,neg:o=>Z(-o,t),eql:(o,u)=>o===u,sqr:o=>Z(o*o,t),add:(o,u)=>Z(o+u,t),sub:(o,u)=>Z(o-u,t),mul:(o,u)=>Z(o*u,t),pow:(o,u)=>ki(c,o,u),div:(o,u)=>Z(o*se(u,t),t),sqrN:o=>o*o,addN:(o,u)=>o+u,subN:(o,u)=>o-u,mulN:(o,u)=>o*u,inv:o=>se(o,t),sqrt:r.sqrt||(o=>(a||(a=Ci(t)),a(c,o))),toBytes:o=>n?fn(o,s):$t(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return n?un(o):ft(o)},invertBatch:o=>$n(c,o),cmov:(o,u,f)=>f?u:o});return Object.freeze(c)}function On(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Nn(t){const e=On(t);return e+Math.ceil(e/2)}function qi(t,e,n=!1){const r=t.length,i=On(e),s=Nn(e);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const a=n?un(t):ft(t),c=Z(a,e-M)+M;return n?fn(c,i):$t(c,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const We=BigInt(0),oe=BigInt(1);function Wt(t,e){const n=e.negate();return t?n:e}function Rn(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function Ft(t,e){Rn(t,e);const n=Math.ceil(e/t)+1,r=2**(t-1),i=2**t,s=Tt(t),a=BigInt(t);return{windows:n,windowSize:r,mask:s,maxNumber:i,shiftBy:a}}function Fe(t,e,n){const{windowSize:r,mask:i,maxNumber:s,shiftBy:a}=n;let c=Number(t&i),o=t>>a;c>r&&(c-=s,o+=oe);const u=e*r,f=u+Math.abs(c)-1,y=c===0,w=c<0,z=e%2!==0;return{nextN:o,offset:f,isZero:y,isNeg:w,isNegF:z,offsetF:u}}function Vi(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((n,r)=>{if(!(n instanceof e))throw new Error("invalid point at index "+r)})}function ji(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((n,r)=>{if(!e.isValid(n))throw new Error("invalid scalar at index "+r)})}const Kt=new WeakMap,Un=new WeakMap;function Gt(t){return Un.get(t)||1}function Mi(t,e){return{constTimeNegate:Wt,hasPrecomputes(n){return Gt(n)!==1},unsafeLadder(n,r,i=t.ZERO){let s=n;for(;r>We;)r&oe&&(i=i.add(s)),s=s.double(),r>>=oe;return i},precomputeWindow(n,r){const{windows:i,windowSize:s}=Ft(r,e),a=[];let c=n,o=c;for(let u=0;u<i;u++){o=c,a.push(o);for(let f=1;f<s;f++)o=o.add(c),a.push(o);c=o.double()}return a},wNAF(n,r,i){let s=t.ZERO,a=t.BASE;const c=Ft(n,e);for(let o=0;o<c.windows;o++){const{nextN:u,offset:f,isZero:y,isNeg:w,isNegF:z,offsetF:R}=Fe(i,o,c);i=u,y?a=a.add(Wt(z,r[R])):s=s.add(Wt(w,r[f]))}return{p:s,f:a}},wNAFUnsafe(n,r,i,s=t.ZERO){const a=Ft(n,e);for(let c=0;c<a.windows&&i!==We;c++){const{nextN:o,offset:u,isZero:f,isNeg:y}=Fe(i,c,a);if(i=o,!f){const w=r[u];s=s.add(y?w.negate():w)}}return s},getPrecomputes(n,r,i){let s=Kt.get(r);return s||(s=this.precomputeWindow(r,n),n!==1&&Kt.set(r,i(s))),s},wNAFCached(n,r,i){const s=Gt(n);return this.wNAF(s,this.getPrecomputes(s,n,i),r)},wNAFCachedUnsafe(n,r,i,s){const a=Gt(n);return a===1?this.unsafeLadder(n,r,s):this.wNAFUnsafe(a,this.getPrecomputes(a,n,i),r,s)},setWindowSize(n,r){Rn(r,e),Un.set(n,r),Kt.delete(n)}}}function Hi(t,e,n,r){Vi(n,t),ji(r,e);const i=n.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const a=t.ZERO,c=Br(BigInt(i));let o=1;c>12?o=c-3:c>4?o=c-2:c>0&&(o=2);const u=Tt(o),f=new Array(Number(u)+1).fill(a),y=Math.floor((e.BITS-1)/o)*o;let w=a;for(let z=y;z>=0;z-=o){f.fill(a);for(let g=0;g<s;g++){const _=r[g],C=Number(_>>BigInt(z)&u);f[C]=f[C].add(n[g])}let R=a;for(let g=f.length-1,_=a;g>0;g--)_=_.add(f[g]),R=R.add(_);if(w=w.add(R),z!==0)for(let g=0;g<o;g++)w=w.double()}return w}function Ln(t){return _i(t.Fp),_t(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...zn(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ke(t){t.lowS!==void 0&&Bt("lowS",t.lowS),t.prehash!==void 0&&Bt("prehash",t.prehash)}function Zi(t){const e=Ln(t);_t(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:n,Fp:r,a:i}=e;if(n){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}class Di extends Error{constructor(e=""){super(e)}}const nt={Err:Di,_tlv:{encode:(t,e)=>{const{Err:n}=nt;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");const r=e.length/2,i=Ot(r);if(i.length/2&128)throw new n("tlv.encode: long form length too big");const s=r>127?Ot(i.length/2|128):"";return Ot(t)+s+i+e},decode(t,e){const{Err:n}=nt;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const i=e[r++],s=!!(i&128);let a=0;if(!s)a=i;else{const o=i&127;if(!o)throw new n("tlv.decode(long): indefinite length not supported");if(o>4)throw new n("tlv.decode(long): byte length is too big");const u=e.subarray(r,r+o);if(u.length!==o)throw new n("tlv.decode: length bytes not complete");if(u[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const f of u)a=a<<8|f;if(r+=o,a<128)throw new n("tlv.decode(long): not minimal encoding")}const c=e.subarray(r,r+a);if(c.length!==a)throw new n("tlv.decode: wrong value length");return{v:c,l:e.subarray(r+a)}}},_int:{encode(t){const{Err:e}=nt;if(t<rt)throw new e("integer: negative integers are not allowed");let n=Ot(t);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=nt;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return ft(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=nt,i=K("signature",t),{v:s,l:a}=r.decode(48,i);if(a.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:o}=r.decode(2,s),{v:u,l:f}=r.decode(2,o);if(f.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(u)}},hexFromSig(t){const{_tlv:e,_int:n}=nt,r=e.encode(2,n.encode(t.r)),i=e.encode(2,n.encode(t.s)),s=r+i;return e.encode(48,s)}};function Xt(t,e){return St($t(t,e))}const rt=BigInt(0),T=BigInt(1);BigInt(2);const Qt=BigInt(3),Yi=BigInt(4);function Wi(t){const e=Zi(t),{Fp:n}=e,r=Ae(e.n,e.nBitLength),i=e.toBytes||((A,d,p)=>{const b=d.toAffine();return Ut(Uint8Array.from([4]),n.toBytes(b.x),n.toBytes(b.y))}),s=e.fromBytes||(A=>{const d=A.subarray(1),p=n.fromBytes(d.subarray(0,n.BYTES)),b=n.fromBytes(d.subarray(n.BYTES,2*n.BYTES));return{x:p,y:b}});function a(A){const{a:d,b:p}=e,b=n.sqr(A),B=n.mul(b,A);return n.add(n.add(B,n.mul(A,d)),p)}function c(A,d){const p=n.sqr(d),b=a(A);return n.eql(p,b)}if(!c(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const o=n.mul(n.pow(e.a,Qt),Yi),u=n.mul(n.sqr(e.b),BigInt(27));if(n.is0(n.add(o,u)))throw new Error("bad curve params: a or b");function f(A){return me(A,T,e.n)}function y(A){const{allowedPrivateKeyLengths:d,nByteLength:p,wrapPrivateKey:b,n:B}=e;if(d&&typeof A!="bigint"){if(Pt(A)&&(A=St(A)),typeof A!="string"||!d.includes(A.length))throw new Error("invalid private key");A=A.padStart(p*2,"0")}let O;try{O=typeof A=="bigint"?A:ft(K("private key",A,p))}catch{throw new Error("invalid private key, expected hex or "+p+" bytes, got "+typeof A)}return b&&(O=Z(O,B)),mt("private key",O,T,B),O}function w(A){if(!(A instanceof g))throw new Error("ProjectivePoint expected")}const z=qe((A,d)=>{const{px:p,py:b,pz:B}=A;if(n.eql(B,n.ONE))return{x:p,y:b};const O=A.is0();d==null&&(d=O?n.ONE:n.inv(B));const U=n.mul(p,d),N=n.mul(b,d),E=n.mul(B,d);if(O)return{x:n.ZERO,y:n.ZERO};if(!n.eql(E,n.ONE))throw new Error("invZ was invalid");return{x:U,y:N}}),R=qe(A=>{if(A.is0()){if(e.allowInfinityPoint&&!n.is0(A.py))return;throw new Error("bad point: ZERO")}const{x:d,y:p}=A.toAffine();if(!n.isValid(d)||!n.isValid(p))throw new Error("bad point: x or y not FE");if(!c(d,p))throw new Error("bad point: equation left != right");if(!A.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(d,p,b){if(d==null||!n.isValid(d))throw new Error("x required");if(p==null||!n.isValid(p)||n.is0(p))throw new Error("y required");if(b==null||!n.isValid(b))throw new Error("z required");this.px=d,this.py=p,this.pz=b,Object.freeze(this)}static fromAffine(d){const{x:p,y:b}=d||{};if(!d||!n.isValid(p)||!n.isValid(b))throw new Error("invalid affine point");if(d instanceof g)throw new Error("projective point not allowed");const B=O=>n.eql(O,n.ZERO);return B(p)&&B(b)?g.ZERO:new g(p,b,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const p=$n(n,d.map(b=>b.pz));return d.map((b,B)=>b.toAffine(p[B])).map(g.fromAffine)}static fromHex(d){const p=g.fromAffine(s(K("pointHex",d)));return p.assertValidity(),p}static fromPrivateKey(d){return g.BASE.multiply(y(d))}static msm(d,p){return Hi(g,r,d,p)}_setWindowSize(d){X.setWindowSize(this,d)}assertValidity(){R(this)}hasEvenY(){const{y:d}=this.toAffine();if(n.isOdd)return!n.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){w(d);const{px:p,py:b,pz:B}=this,{px:O,py:U,pz:N}=d,E=n.eql(n.mul(p,N),n.mul(O,B)),$=n.eql(n.mul(b,N),n.mul(U,B));return E&&$}negate(){return new g(this.px,n.neg(this.py),this.pz)}double(){const{a:d,b:p}=e,b=n.mul(p,Qt),{px:B,py:O,pz:U}=this;let N=n.ZERO,E=n.ZERO,$=n.ZERO,x=n.mul(B,B),V=n.mul(O,O),h=n.mul(U,U),l=n.mul(B,O);return l=n.add(l,l),$=n.mul(B,U),$=n.add($,$),N=n.mul(d,$),E=n.mul(b,h),E=n.add(N,E),N=n.sub(V,E),E=n.add(V,E),E=n.mul(N,E),N=n.mul(l,N),$=n.mul(b,$),h=n.mul(d,h),l=n.sub(x,h),l=n.mul(d,l),l=n.add(l,$),$=n.add(x,x),x=n.add($,x),x=n.add(x,h),x=n.mul(x,l),E=n.add(E,x),h=n.mul(O,U),h=n.add(h,h),x=n.mul(h,l),N=n.sub(N,x),$=n.mul(h,V),$=n.add($,$),$=n.add($,$),new g(N,E,$)}add(d){w(d);const{px:p,py:b,pz:B}=this,{px:O,py:U,pz:N}=d;let E=n.ZERO,$=n.ZERO,x=n.ZERO;const V=e.a,h=n.mul(e.b,Qt);let l=n.mul(p,O),m=n.mul(b,U),I=n.mul(B,N),v=n.add(p,b),S=n.add(O,U);v=n.mul(v,S),S=n.add(l,m),v=n.sub(v,S),S=n.add(p,B);let L=n.add(O,N);return S=n.mul(S,L),L=n.add(l,I),S=n.sub(S,L),L=n.add(b,B),E=n.add(U,N),L=n.mul(L,E),E=n.add(m,I),L=n.sub(L,E),x=n.mul(V,S),E=n.mul(h,I),x=n.add(E,x),E=n.sub(m,x),x=n.add(m,x),$=n.mul(E,x),m=n.add(l,l),m=n.add(m,l),I=n.mul(V,I),S=n.mul(h,S),m=n.add(m,I),I=n.sub(l,I),I=n.mul(V,I),S=n.add(S,I),l=n.mul(m,S),$=n.add($,l),l=n.mul(L,S),E=n.mul(v,E),E=n.sub(E,l),l=n.mul(v,m),x=n.mul(L,x),x=n.add(x,l),new g(E,$,x)}subtract(d){return this.add(d.negate())}is0(){return this.equals(g.ZERO)}wNAF(d){return X.wNAFCached(this,d,g.normalizeZ)}multiplyUnsafe(d){const{endo:p,n:b}=e;mt("scalar",d,rt,b);const B=g.ZERO;if(d===rt)return B;if(this.is0()||d===T)return this;if(!p||X.hasPrecomputes(this))return X.wNAFCachedUnsafe(this,d,g.normalizeZ);let{k1neg:O,k1:U,k2neg:N,k2:E}=p.splitScalar(d),$=B,x=B,V=this;for(;U>rt||E>rt;)U&T&&($=$.add(V)),E&T&&(x=x.add(V)),V=V.double(),U>>=T,E>>=T;return O&&($=$.negate()),N&&(x=x.negate()),x=new g(n.mul(x.px,p.beta),x.py,x.pz),$.add(x)}multiply(d){const{endo:p,n:b}=e;mt("scalar",d,T,b);let B,O;if(p){const{k1neg:U,k1:N,k2neg:E,k2:$}=p.splitScalar(d);let{p:x,f:V}=this.wNAF(N),{p:h,f:l}=this.wNAF($);x=X.constTimeNegate(U,x),h=X.constTimeNegate(E,h),h=new g(n.mul(h.px,p.beta),h.py,h.pz),B=x.add(h),O=V.add(l)}else{const{p:U,f:N}=this.wNAF(d);B=U,O=N}return g.normalizeZ([B,O])[0]}multiplyAndAddUnsafe(d,p,b){const B=g.BASE,O=(N,E)=>E===rt||E===T||!N.equals(B)?N.multiplyUnsafe(E):N.multiply(E),U=O(this,p).add(O(d,b));return U.is0()?void 0:U}toAffine(d){return z(this,d)}isTorsionFree(){const{h:d,isTorsionFree:p}=e;if(d===T)return!0;if(p)return p(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:p}=e;return d===T?this:p?p(g,this):this.multiplyUnsafe(e.h)}toRawBytes(d=!0){return Bt("isCompressed",d),this.assertValidity(),i(g,this,d)}toHex(d=!0){return Bt("isCompressed",d),St(this.toRawBytes(d))}}g.BASE=new g(e.Gx,e.Gy,n.ONE),g.ZERO=new g(n.ZERO,n.ONE,n.ZERO);const{endo:_,nBitLength:C}=e,X=Mi(g,_?Math.ceil(C/2):C);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:y,weierstrassEquation:a,isWithinCurveOrder:f}}function Fi(t){const e=Ln(t);return _t(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Ki(t){const e=Fi(t),{Fp:n,n:r,nByteLength:i,nBitLength:s}=e,a=n.BYTES+1,c=2*n.BYTES+1;function o(h){return Z(h,r)}function u(h){return se(h,r)}const{ProjectivePoint:f,normPrivateKeyToScalar:y,weierstrassEquation:w,isWithinCurveOrder:z}=Wi({...e,toBytes(h,l,m){const I=l.toAffine(),v=n.toBytes(I.x),S=Ut;return Bt("isCompressed",m),m?S(Uint8Array.from([l.hasEvenY()?2:3]),v):S(Uint8Array.from([4]),v,n.toBytes(I.y))},fromBytes(h){const l=h.length,m=h[0],I=h.subarray(1);if(l===a&&(m===2||m===3)){const v=ft(I);if(!me(v,T,n.ORDER))throw new Error("Point is not on curve");const S=w(v);let L;try{L=n.sqrt(S)}catch(G){const H=G instanceof Error?": "+G.message:"";throw new Error("Point is not on curve"+H)}const j=(L&T)===T;return(m&1)===1!==j&&(L=n.neg(L)),{x:v,y:L}}else if(l===c&&m===4){const v=n.fromBytes(I.subarray(0,n.BYTES)),S=n.fromBytes(I.subarray(n.BYTES,2*n.BYTES));return{x:v,y:S}}else{const v=a,S=c;throw new Error("invalid Point, expected length of "+v+", or uncompressed "+S+", got "+l)}}});function R(h){const l=r>>T;return h>l}function g(h){return R(h)?o(-h):h}const _=(h,l,m)=>ft(h.slice(l,m));class C{constructor(l,m,I){mt("r",l,T,r),mt("s",m,T,r),this.r=l,this.s=m,I!=null&&(this.recovery=I),Object.freeze(this)}static fromCompact(l){const m=i;return l=K("compactSignature",l,m*2),new C(_(l,0,m),_(l,m,2*m))}static fromDER(l){const{r:m,s:I}=nt.toSig(K("DER",l));return new C(m,I)}assertValidity(){}addRecoveryBit(l){return new C(this.r,this.s,l)}recoverPublicKey(l){const{r:m,s:I,recovery:v}=this,S=B(K("msgHash",l));if(v==null||![0,1,2,3].includes(v))throw new Error("recovery id invalid");const L=v===2||v===3?m+e.n:m;if(L>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=(v&1)===0?"02":"03",J=f.fromHex(j+Xt(L,n.BYTES)),G=u(L),H=o(-S*G),ht=o(I*G),ot=f.BASE.multiplyAndAddUnsafe(J,H,ht);if(!ot)throw new Error("point at infinify");return ot.assertValidity(),ot}hasHighS(){return R(this.s)}normalizeS(){return this.hasHighS()?new C(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Rt(this.toDERHex())}toDERHex(){return nt.hexFromSig(this)}toCompactRawBytes(){return Rt(this.toCompactHex())}toCompactHex(){const l=i;return Xt(this.r,l)+Xt(this.s,l)}}const X={isValidPrivateKey(h){try{return y(h),!0}catch{return!1}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{const h=Nn(e.n);return qi(e.randomBytes(h),e.n)},precompute(h=8,l=f.BASE){return l._setWindowSize(h),l.multiply(BigInt(3)),l}};function A(h,l=!0){return f.fromPrivateKey(h).toRawBytes(l)}function d(h){if(typeof h=="bigint")return!1;if(h instanceof f)return!0;const m=K("key",h).length,I=n.BYTES,v=I+1,S=2*I+1;if(!(e.allowedPrivateKeyLengths||i===v))return m===v||m===S}function p(h,l,m=!0){if(d(h)===!0)throw new Error("first arg must be private key");if(d(l)===!1)throw new Error("second arg must be public key");return f.fromHex(l).multiply(y(h)).toRawBytes(m)}const b=e.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const l=ft(h),m=h.length*8-s;return m>0?l>>BigInt(m):l},B=e.bits2int_modN||function(h){return o(b(h))},O=Tt(s);function U(h){return mt("num < 2^"+s,h,rt,O),$t(h,i)}function N(h,l,m=E){if(["recovered","canonical"].some(at=>at in m))throw new Error("sign() legacy options not supported");const{hash:I,randomBytes:v}=e;let{lowS:S,prehash:L,extraEntropy:j}=m;S==null&&(S=!0),h=K("msgHash",h),Ke(m),L&&(h=K("prehashed msgHash",I(h)));const J=B(h),G=y(l),H=[U(G),U(J)];if(j!=null&&j!==!1){const at=j===!0?v(n.BYTES):j;H.push(K("extraEntropy",at))}const ht=Ut(...H),ot=J;function Mt(at){const yt=b(at);if(!z(yt))return;const Ht=u(yt),Et=f.BASE.multiply(yt).toAffine(),ct=o(Et.x);if(ct===rt)return;const xt=o(Ht*o(ot+ct*G));if(xt===rt)return;let pt=(Et.x===ct?0:2)|Number(Et.y&T),ze=xt;return S&&R(xt)&&(ze=g(xt),pt^=1),new C(ct,ze,pt)}return{seed:ht,k2sig:Mt}}const E={lowS:e.lowS,prehash:!1},$={lowS:e.lowS,prehash:!1};function x(h,l,m=E){const{seed:I,k2sig:v}=N(h,l,m),S=e;return Sr(S.hash.outputLen,S.nByteLength,S.hmac)(I,v)}f.BASE._setWindowSize(8);function V(h,l,m,I=$){const v=h;l=K("msgHash",l),m=K("publicKey",m);const{lowS:S,prehash:L,format:j}=I;if(Ke(I),"strict"in I)throw new Error("options.strict was renamed to lowS");if(j!==void 0&&j!=="compact"&&j!=="der")throw new Error("format must be compact or der");const J=typeof v=="string"||Pt(v),G=!J&&!j&&typeof v=="object"&&v!==null&&typeof v.r=="bigint"&&typeof v.s=="bigint";if(!J&&!G)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let H,ht;try{if(G&&(H=new C(v.r,v.s)),J){try{j!=="compact"&&(H=C.fromDER(v))}catch(pt){if(!(pt instanceof nt.Err))throw pt}!H&&j!=="der"&&(H=C.fromCompact(v))}ht=f.fromHex(m)}catch{return!1}if(!H||S&&H.hasHighS())return!1;L&&(l=e.hash(l));const{r:ot,s:Mt}=H,at=B(l),yt=u(Mt),Ht=o(at*yt),Et=o(ot*yt),ct=f.BASE.multiplyAndAddUnsafe(ht,Ht,Et)?.toAffine();return ct?o(ct.x)===ot:!1}return{CURVE:e,getPublicKey:A,getSharedSecret:p,sign:x,verify:V,ProjectivePoint:f,Signature:C,utils:X}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Gi(t){return{hash:t,hmac:(e,...n)=>nr(t,e,rr(...n)),randomBytes:er}}function Xi(t,e){const n=r=>Ki({...t,...Gi(r)});return{...n(e),create:n}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Cn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ge=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Qi=BigInt(0),Ji=BigInt(1),ae=BigInt(2),Xe=(t,e)=>(t+e/ae)/e;function ts(t){const e=Cn,n=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),a=BigInt(23),c=BigInt(44),o=BigInt(88),u=t*t*t%e,f=u*u*t%e,y=F(f,n,e)*f%e,w=F(y,n,e)*f%e,z=F(w,ae,e)*u%e,R=F(z,i,e)*z%e,g=F(R,s,e)*R%e,_=F(g,c,e)*g%e,C=F(_,o,e)*_%e,X=F(C,c,e)*g%e,A=F(X,n,e)*f%e,d=F(A,a,e)*R%e,p=F(d,r,e)*u%e,b=F(p,ae,e);if(!ce.eql(ce.sqr(b),t))throw new Error("Cannot find square root");return b}const ce=Ae(Cn,void 0,void 0,{sqrt:ts}),qt=Xi({a:Qi,b:BigInt(7),Fp:ce,n:Ge,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Ge,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ji*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,a=BigInt("0x100000000000000000000000000000000"),c=Xe(s*t,e),o=Xe(-r*t,e);let u=Z(t-c*n-o*i,e),f=Z(-c*r-o*s,e);const y=u>a,w=f>a;if(y&&(u=e-u),w&&(f=e-f),u>a||f>a)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:y,k1:u,k2neg:w,k2:f}}}},ir);function Ie(t,e={}){const{recovered:n}=e;if(typeof t.r>"u")throw new Jt({signature:t});if(typeof t.s>"u")throw new Jt({signature:t});if(n&&typeof t.yParity>"u")throw new Jt({signature:t});if(t.r<0n||t.r>He)throw new as({value:t.r});if(t.s<0n||t.s>He)throw new cs({value:t.s});if(typeof t.yParity=="number"&&t.yParity!==0&&t.yParity!==1)throw new Vt({value:t.yParity})}function es(t){return Tn(W(t))}function Tn(t){if(t.length!==130&&t.length!==132)throw new os({signature:t});const e=BigInt(k(t,0,32)),n=BigInt(k(t,32,64)),r=(()=>{const i=+`0x${t.slice(130)}`;if(!Number.isNaN(i))try{return Pe(i)}catch{throw new Vt({value:i})}})();return typeof r>"u"?{r:e,s:n}:{r:e,s:n,yParity:r}}function _n(t){if(!(typeof t.r>"u")&&!(typeof t.s>"u"))return kn(t)}function kn(t){const e=typeof t=="string"?Tn(t):t instanceof Uint8Array?es(t):typeof t.r=="string"?rs(t):t.v?ns(t):{r:t.r,s:t.s,...typeof t.yParity<"u"?{yParity:t.yParity}:{}};return Ie(e),e}function ns(t){return{r:t.r,s:t.s,yParity:Pe(t.v)}}function rs(t){const e=(()=>{const n=t.v?Number(t.v):void 0;let r=t.yParity?Number(t.yParity):void 0;if(typeof n=="number"&&typeof r!="number"&&(r=Pe(n)),typeof r!="number")throw new Vt({value:t.yParity});return r})();return{r:BigInt(t.r),s:BigInt(t.s),yParity:e}}function js(t){Ie(t);const e=t.r,n=t.s;return Y(q(e,{size:32}),q(n,{size:32}),typeof t.yParity=="number"?q(ss(t.yParity),{size:1}):"0x")}function is(t){const{r:e,s:n,yParity:r}=t;return[r?"0x01":"0x",e===0n?"0x":Re(q(e)),n===0n?"0x":Re(q(n))]}function Pe(t){if(t===0||t===27)return 0;if(t===1||t===28)return 1;if(t>=35)return t%2===0?1:0;throw new us({value:t})}function ss(t){if(t===0)return 27;if(t===1)return 28;throw new Vt({value:t})}class os extends P{constructor({signature:e}){super(`Value \`${e}\` is an invalid signature size.`,{metaMessages:["Expected: 64 bytes or 65 bytes.",`Received ${st(It(e))} bytes.`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidSerializedSizeError"})}}class Jt extends P{constructor({signature:e}){super(`Signature \`${le(e)}\` is missing either an \`r\`, \`s\`, or \`yParity\` property.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.MissingPropertiesError"})}}class as extends P{constructor({value:e}){super(`Value \`${e}\` is an invalid r value. r must be a positive integer less than 2^256.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidRError"})}}class cs extends P{constructor({value:e}){super(`Value \`${e}\` is an invalid s value. s must be a positive integer less than 2^256.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidSError"})}}class Vt extends P{constructor({value:e}){super(`Value \`${e}\` is an invalid y-parity value. Y-parity must be 0 or 1.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidYParityError"})}}class us extends P{constructor({value:e}){super(`Value \`${e}\` is an invalid v value. v must be 27, 28 or >=35.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Signature.InvalidVError"})}}function fs(t,e={}){return typeof t.chainId=="string"?ds(t):{...t,...e.signature}}function ds(t){const{address:e,chainId:n,nonce:r}=t,i=_n(t);return{address:e,chainId:Number(n),nonce:BigInt(r),...i}}function ls(t){return hs(t,{presign:!0})}function hs(t,e={}){const{presign:n}=e;return kt(Y("0x05",zi(ys(n?{address:t.address,chainId:t.chainId,nonce:t.nonce}:t))))}function ys(t){const{address:e,chainId:n,nonce:r}=t,i=_n(t);return[n?q(n):"0x",e,r?q(r):"0x",...i?is(i):[]]}let ps=!1;function Ms(t){const{privateKey:e}=t,n=qt.ProjectivePoint.fromPrivateKey(It(e).slice(2));return pn(n)}function Hs(t={}){const{as:e="Hex"}=t,n=qt.utils.randomPrivateKey();return e==="Hex"?W(n):n}function gs(t){return ti(ms(t))}function ms(t){const{payload:e,signature:n}=t,{r,s:i,yParity:s}=n,c=new qt.Signature(BigInt(r),BigInt(i)).addRecoveryBit(s).recoverPublicKey(It(e).substring(2));return pn(c)}function Zs(t){const{extraEntropy:e=ps,hash:n,payload:r,privateKey:i}=t,{r:s,s:a,recovery:c}=qt.sign(Lt(r),Lt(i),{extraEntropy:typeof e=="boolean"?e:It(e).slice(2),lowS:!0,...n?{prehash:!0}:{}});return{r:s,s:a,yParity:c}}const qn="0x8010801080108010801080108010801080108010801080108010801080108010",Vn=bn("(uint256 chainId, address delegation, uint256 nonce, uint8 yParity, uint256 r, uint256 s), address to, bytes data");function $e(t){if(typeof t=="string"){if(k(t,-32)!==qn)throw new Es(t)}else Ie(t.authorization)}function ws(t){$e(t);const e=tn(k(t,-64,-32)),n=k(t,-e-64,-64),r=k(t,0,-e-64),[i,s,a]=Bi(Vn,n);return{authorization:fs({address:i.delegation,chainId:Number(i.chainId),nonce:i.nonce,yParity:i.yParity,r:i.r,s:i.s}),signature:r,...a&&a!=="0x"?{data:a,to:s}:{}}}function Ds(t){const{data:e,signature:n}=t;$e(t);const r=gs({payload:ls(t.authorization),signature:kn(t.authorization)}),i=Be(Vn,[{...t.authorization,delegation:t.authorization.address,chainId:BigInt(t.authorization.chainId)},t.to??r,e??"0x"]),s=q(st(i),{size:32});return Y(n,i,s,qn)}function bs(t){try{return $e(t),!0}catch{return!1}}let Es=class extends P{constructor(e){super(`Value \`${e}\` is an invalid ERC-8010 wrapped signature.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SignatureErc8010.InvalidWrappedSignatureError"})}};class xs extends sr{constructor({address:e}){super(`No EIP-712 domain found on contract "${e}".`,{metaMessages:["Ensure that:",`- The contract is deployed at the address "${e}".`,"- `eip712Domain()` function exists on the contract.","- `eip712Domain()` function matches signature to ERC-5267 specification."],name:"Eip712DomainNotFoundError"})}}async function Ws(t,e){const{address:n,factory:r,factoryData:i}=e;try{const[s,a,c,o,u,f,y]=await Ct(t,ye,"readContract")({abi:vs,address:n,functionName:"eip712Domain",factory:r,factoryData:i});return{domain:{name:a,version:c,chainId:Number(o),verifyingContract:u,salt:f},extensions:y,fields:s}}catch(s){const a=s;throw a.name==="ContractFunctionExecutionError"&&a.cause.name==="ContractFunctionZeroDataError"?new xs({address:n}):a}}const vs=[{inputs:[],name:"eip712Domain",outputs:[{name:"fields",type:"bytes1"},{name:"name",type:"string"},{name:"version",type:"string"},{name:"chainId",type:"uint256"},{name:"verifyingContract",type:"address"},{name:"salt",type:"bytes32"},{name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function"}];function ue(t){let e=!0,n="",r=0,i="",s=!1;for(let a=0;a<t.length;a++){const c=t[a];if(["(",")",","].includes(c)&&(e=!0),c==="("&&r++,c===")"&&r--,!!e){if(r===0){if(c===" "&&["event","function","error",""].includes(i))i="";else if(i+=c,c===")"){s=!0;break}continue}if(c===" "){t[a-1]!==","&&n!==","&&n!==",("&&(n="",e=!1);continue}i+=c,n+=c}}if(!s)throw new P("Unable to normalize signature.");return i}function fe(t,e){const n=typeof t,r=e.type;switch(r){case"address":return ne(t,{strict:!1});case"bool":return n==="boolean";case"function":return n==="string";case"string":return n==="string";default:return r==="tuple"&&"components"in e?Object.values(e.components).every((i,s)=>fe(Object.values(t)[s],i)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(r)?n==="number"||n==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)?n==="string"||t instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)?Array.isArray(t)&&t.every(i=>fe(i,{...e,type:r.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function jn(t,e,n){for(const r in t){const i=t[r],s=e[r];if(i.type==="tuple"&&s.type==="tuple"&&"components"in i&&"components"in s)return jn(i.components,s.components,n[r]);const a=[i.type,s.type];if(a.includes("address")&&a.includes("bytes20")?!0:a.includes("address")&&a.includes("string")?ne(n[r],{strict:!1}):a.includes("address")&&a.includes("bytes")?ne(n[r],{strict:!1}):!1)return a}}function Bs(t,e={}){const{prepare:n=!0}=e,r=Array.isArray(t)||typeof t=="string"?Te(t):t;return{...r,...n?{hash:gt(r)}:{}}}function jt(t,e,n){const{args:r=[],prepare:i=!0}=n??{},s=en(e,{strict:!1}),a=t.filter(u=>s?u.type==="function"||u.type==="error"?Mn(u)===k(e,0,4):u.type==="event"?gt(u)===e:!1:"name"in u&&u.name===e);if(a.length===0)throw new de({name:e});if(a.length===1)return{...a[0],...i?{hash:gt(a[0])}:{}};let c;for(const u of a){if(!("inputs"in u))continue;if(!r||r.length===0){if(!u.inputs||u.inputs.length===0)return{...u,...i?{hash:gt(u)}:{}};continue}if(!u.inputs||u.inputs.length===0||u.inputs.length!==r.length)continue;if(r.every((y,w)=>{const z="inputs"in u&&u.inputs[w];return z?fe(y,z):!1})){if(c&&"inputs"in c&&c.inputs){const y=jn(u.inputs,c.inputs,r);if(y)throw new As({abiItem:u,type:y[0]},{abiItem:c,type:y[1]})}c=u}}const o=(()=>{if(c)return c;const[u,...f]=a;return{...u,overloads:f}})();if(!o)throw new de({name:e});return{...o,...i?{hash:gt(o)}:{}}}function Mn(...t){const e=(()=>{if(Array.isArray(t[0])){const[n,r]=t;return jt(n,r)}return t[0]})();return k(gt(e),0,4)}function Ss(...t){const e=(()=>{if(Array.isArray(t[0])){const[r,i]=t;return jt(r,i)}return t[0]})(),n=typeof e=="string"?e:te(e);return ue(n)}function gt(...t){const e=(()=>{if(Array.isArray(t[0])){const[n,r]=t;return jt(n,r)}return t[0]})();return typeof e!="string"&&"hash"in e&&e.hash?e.hash:kt(he(Ss(e)))}class As extends P{constructor(e,n){super("Found ambiguous types in overloaded ABI Items.",{metaMessages:[`\`${e.type}\` in \`${ue(te(e.abiItem))}\`, and`,`\`${n.type}\` in \`${ue(te(n.abiItem))}\``,"","These types encode differently and cannot be distinguished at runtime.","Remove one of the ambiguous items in the ABI."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiItem.AmbiguityError"})}}class de extends P{constructor({name:e,data:n,type:r="item"}){const i=e?` with name "${e}"`:n?` with data "${n}"`:"";super(`ABI ${r}${i} not found.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiItem.NotFoundError"})}}function Fs(...t){const[e,n=[]]=(()=>{if(Array.isArray(t[0])){const[u,f,y]=t;return[Qe(u,f,{args:y}),y]}const[c,o]=t;return[c,o]})(),{overloads:r}=e,i=r?Qe([e,...r],e.name,{args:n}):e,s=Is(i),a=n.length>0?Be(i.inputs,n):void 0;return a?Y(s,a):s}function Ks(t,e={}){return Bs(t,e)}function Qe(t,e,n){const r=jt(t,e,n);if(r.type!=="function")throw new de({name:e,type:"function"});return r}function Is(t){return Mn(t)}const Gs="0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee",Xs="0x0000000000000000000000000000000000000000",Hn="0x6492649264926492649264926492649264926492649264926492649264926492";function Ps(t){if(k(t,-32)!==Hn)throw new Os(t)}function $s(t){const{data:e,signature:n,to:r}=t;return Y(Be(bn("address, bytes, bytes"),[r,e,n]),Hn)}function zs(t){try{return Ps(t),!0}catch{return!1}}class Os extends P{constructor(e){super(`Value \`${e}\` is an invalid ERC-6492 wrapped signature.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SignatureErc6492.InvalidWrappedSignatureError"})}}function Ns({r:t,s:e,to:n="hex",v:r,yParity:i}){const s=(()=>{if(i===0||i===1)return i;if(r&&(r===27n||r===28n||r>=35n))return r%2n===0n?1:0;throw new Error("Invalid `v` or `yParity` value")})(),a=`0x${new or.Signature(Ue(t),Ue(e)).toCompactHex()}${s===0?"1b":"1c"}`;return n==="hex"?a:ar(a)}async function Qs(t,e){const{address:n,hash:r,erc6492VerifierAddress:i=e.universalSignatureVerifierAddress??t.chain?.contracts?.erc6492Verifier?.address,multicallAddress:s=e.multicallAddress??t.chain?.contracts?.multicall3?.address}=e,a=(()=>{const c=e.signature;return cr(c)?c:typeof c=="object"&&"r"in c&&"s"in c?Ns(c):ur(c)})();try{return bs(a)?await Rs(t,{...e,multicallAddress:s,signature:a}):await Us(t,{...e,verifierAddress:i,signature:a})}catch(c){try{if(on(Je(n),await fr({hash:r,signature:a})))return!0}catch{}if(c instanceof lt)return!1;throw c}}async function Rs(t,e){const{address:n,blockNumber:r,blockTag:i,hash:s,multicallAddress:a}=e,{authorization:c,data:o,signature:u,to:f}=ws(e.signature);if(await dr(t,{address:n,blockNumber:r,blockTag:i})===lr(["0xef0100",c.address]))return await Ls(t,{address:n,blockNumber:r,blockTag:i,hash:s,signature:u});const w={address:c.address,chainId:Number(c.chainId),nonce:Number(c.nonce),r:Le(c.r,{size:32}),s:Le(c.s,{size:32}),yParity:c.yParity};if(!await xr({address:n,authorization:w}))throw new lt;const R=await Ct(t,ye,"readContract")({...a?{address:a}:{code:yr},authorizationList:[w],abi:hr,blockNumber:r,blockTag:"pending",functionName:"aggregate3",args:[[...o?[{allowFailure:!0,target:f??n,callData:o}]:[],{allowFailure:!0,target:n,callData:rn({abi:sn,functionName:"isValidSignature",args:[s,u]})}]]});if(R[R.length-1]?.returnData?.startsWith("0x1626ba7e"))return!0;throw new lt}async function Us(t,e){const{address:n,factory:r,factoryData:i,hash:s,signature:a,verifierAddress:c,...o}=e,u=await(async()=>!r&&!i||zs(a)?a:$s({data:i,signature:a,to:r}))(),f=c?{to:c,data:rn({abi:Ce,functionName:"isValidSig",args:[n,s,u]}),...o}:{data:pr({abi:Ce,args:[n,s,u],bytecode:gr}),...o},{data:y}=await Ct(t,mr,"call")(f).catch(w=>{throw w instanceof wr?new lt:w});if(br(y??"0x0"))return!0;throw new lt}async function Ls(t,e){const{address:n,blockNumber:r,blockTag:i,hash:s,signature:a}=e;if((await Ct(t,ye,"readContract")({address:n,abi:sn,args:[s,a],blockNumber:r,blockTag:i,functionName:"isValidSignature"}).catch(o=>{throw o instanceof Er?new lt:o})).startsWith("0x1626ba7e"))return!0;throw new lt}class lt extends Error{}export{_s as A,Wr as B,ie as C,bn as D,js as E,Ae as F,Zs as G,Vs as H,Me as I,ti as J,gn as K,Is as L,Ms as M,de as N,Qe as O,gs as P,Tn as Q,Ds as R,Hs as S,Fs as a,Ks as b,Gs as c,Mn as d,Be as e,Bs as f,Ws as g,jt as h,we as i,Xi as j,ps as k,pn as l,kt as m,Jr as n,mn as o,ne as p,ei as q,ii as r,Ur as s,ks as t,Lt as u,Qs as v,Tr as w,Cr as x,Rr as y,Xs as z};
